## 滑动窗口

[1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)

```C++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int res=accumulate(cardPoints.begin(),cardPoints.begin()+k,0);
        int m=k;
        int n=cardPoints.size();
        int temp=res;
        while(m!=0){
            temp=temp+cardPoints[--n]-cardPoints[--m];
            res=max(res,temp);
        }
        return res;
    }
};//看了别人的思路，自己写出来的
```

[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

这题稍微简单一点，但是自己写的过程中没有注意下标越界
```C++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if(s1.size()>s2.size())return false;
        vector<int> v_s1(26,0);
        vector<int> v_lr(26,0);
        for(int i=0;i<s1.size();++i){//构造字典
            v_s1[s1[i]-'a']++;
            v_lr[s2[i]-'a']++;
        }
        for(int left=0,right=s1.size();right<s2.size();++left,++right){
            if(v_lr==v_s1)return true;//滑动窗口
            v_lr[s2[left]-'a']--;
            v_lr[s2[right]-'a']++;
        }
        return v_s1==v_lr;//滑到最后还要进行一次比较
    }
};
```

```C++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if(s1.size()>s2.size())return false;
        int left=0,right=s1.size()-1;
        vector<int> v_s1(26,0);
        vector<int> v_lr(26,0);
        for(int i=0;i<s1.size();++i){
            v_s1[s1[i]-'a']++;
            v_lr[s2[i]-'a']++;
        }
        while(right<s2.size()-1){
            if(v_lr==v_s1)return true;
            //一开始把left++写在这里，就错了
            right++;
            v_lr[s2[left]-'a']--;
            v_lr[s2[right]-'a']++;
            left++;
        }
        return v_s1==v_lr;
    }
};
```


[1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

使用 left 和 right 两个指针，分别指向滑动窗口的左右边界。
right 主动右移：right 指针每次移动一步。当 A[right] 为 0，说明滑动窗口内增加了一个 0；
left 被动右移：判断此时窗口内 0 的个数，如果超过了 K，则 left 指针被迫右移，直至窗口内的 0 的个数小于等于 K 为止。

链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/
```C++
class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
        int res = 0,t = K,left = 0;
        for(int right = 0; right < A.size(); ++right){
            if(A[right] == 0)t--;
            while(t < 0){
                if(A[left++] == 0)t++;
            }
            res = max(res,right-left+1);
        }
        return res;
    }
};
```
